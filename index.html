<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç´å±‹æ¸¯ å¹²æ½Ÿå‡ºç¾äºˆæ¸¬ã‚·ã‚¹ãƒ†ãƒ </title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; background: linear-gradient(135deg, #e0f2fe 0%, #cffafe 100%); }
        .container { max-width: 1200px; margin: 0 auto; padding: 0.75rem; }
        .card { background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 1rem; margin-bottom: 1rem; }
        .header { font-size: 1.5rem; font-weight: bold; color: #1f2937; margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.5rem; }
        .subtitle { color: #6b7280; margin-bottom: 1rem; font-size: 0.875rem; }
        .stats-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.75rem; margin-bottom: 1rem; }
        .stat-card { background: white; border-radius: 8px; box-shadow: 0 1px 4px rgba(0,0,0,0.1); padding: 0.75rem; }
        .stat-label { font-size: 0.75rem; color: #6b7280; margin-bottom: 0.25rem; }
        .stat-value { font-size: 1.25rem; font-weight: bold; }
        .tabs { display: flex; gap: 0.5rem; margin-bottom: 1rem; flex-wrap: wrap; }
        .tab { padding: 0.5rem 1rem; border-radius: 8px; border: none; font-weight: 500; cursor: pointer; transition: all 0.2s; font-size: 0.875rem; }
        .tab.active { background: #2563eb; color: white; }
        .tab.inactive { background: #f3f4f6; color: #374151; }
        .tab.inactive:hover { background: #e5e7eb; }
        .update-info { display: flex; flex-direction: column; gap: 0.5rem; font-size: 0.75rem; color: #6b7280; }
        .update-item { display: flex; align-items: center; gap: 0.5rem; }
        
        /* ã‚°ãƒ©ãƒ•ã‚³ãƒ³ãƒ†ãƒŠ - ã‚¹ãƒãƒ›å¯¾å¿œ */
        .chart-wrapper { 
            width: 100%; 
            overflow-x: auto; 
            -webkit-overflow-scrolling: touch;
            margin-bottom: 1rem;
        }
        .chart-wrapper.no-scroll {
            overflow-x: hidden;
        }
        .chart-container { 
            min-width: 600px; /* äºˆæ¸¬ã‚°ãƒ©ãƒ•ï¼ˆ7æ—¥é–“ï¼‰ã¯ã‚¹ãƒãƒ›ã§æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« */
            height: 300px;
            position: relative;
        }
        .chart-container.full-width {
            min-width: 100%; /* å®Ÿæ¸¬ã‚°ãƒ©ãƒ•ï¼ˆ24æ™‚é–“ï¼‰ã¯ç”»é¢å¹…ã«åã‚ã‚‹ */
        }
        
        /* ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆä»¥ä¸Š */
        @media (min-width: 768px) {
            .container { padding: 1rem; }
            .card { padding: 1.5rem; margin-bottom: 1.5rem; }
            .header { font-size: 2rem; gap: 0.75rem; }
            .subtitle { font-size: 1rem; }
            .stats-grid { grid-template-columns: repeat(4, 1fr); gap: 1rem; }
            .stat-card { padding: 1rem; }
            .stat-label { font-size: 0.875rem; }
            .stat-value { font-size: 1.5rem; }
            .tab { padding: 0.75rem 1.5rem; font-size: 1rem; }
            .update-info { flex-direction: row; flex-wrap: wrap; font-size: 0.875rem; }
            .chart-container { 
                min-width: 100%; 
                height: 400px;
            }
        }
        
        .table-container { overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 0.5rem; text-align: left; border-bottom: 1px solid #e5e7eb; font-size: 0.875rem; }
        th { background: #f9fafb; font-weight: 600; color: #374151; }
        tr:hover { background: #f9fafb; }
        .period-card { border-left: 4px solid #d1d5db; padding: 0.75rem; margin-bottom: 0.75rem; border-radius: 4px; }
        .period-card.daytime { background: #fffbeb; border-left-color: #f59e0b; }
        .period-card.nighttime { background: #f3f4f6; border-left-color: #9ca3af; }
        .period-header { display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.5rem; flex-wrap: wrap; gap: 0.5rem; }
        .period-time { font-weight: 600; color: #1f2937; font-size: 0.875rem; }
        .badge { padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.625rem; font-weight: 600; white-space: nowrap; }
        .badge-green { background: #d1fae5; color: #065f46; }
        .badge-blue { background: #dbeafe; color: #1e40af; }
        .badge-gray { background: #f3f4f6; color: #374151; }
        .info-box { background: #eff6ff; border: 1px solid #bfdbfe; border-radius: 8px; padding: 1rem; font-size: 0.875rem; }
        .info-box ul { margin-left: 1.5rem; margin-top: 0.5rem; }
        .info-box li { margin-bottom: 0.25rem; }
        .loading { text-align: center; padding: 2rem; }
        .error { background: #fee; border: 1px solid #fcc; color: #c00; padding: 1rem; border-radius: 8px; font-size: 0.875rem; }
        .settings-panel { display: grid; grid-template-columns: 1fr; gap: 1rem; margin-top: 1rem; }
        .setting-item label { display: block; font-size: 0.875rem; font-weight: 500; color: #374151; margin-bottom: 0.5rem; }
        .setting-item input[type="range"] { width: 100%; }
        
        @media (min-width: 768px) {
            .settings-panel { grid-template-columns: repeat(3, 1fr); }
            th, td { padding: 0.75rem; font-size: 1rem; }
            .period-card { padding: 1rem; margin-bottom: 1rem; }
            .period-time { font-size: 1rem; }
            .badge { padding: 0.25rem 0.75rem; font-size: 0.75rem; }
        }
        
        /* ã‚°ãƒ©ãƒ•ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒ’ãƒ³ãƒˆ */
        .scroll-hint {
            text-align: center;
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 0.5rem;
        }
        
        @media (min-width: 768px) {
            .scroll-hint { display: none; }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;

        const TideChart = ({ data, threshold, title, comparisonData, showCurrentTime }) => {
            const canvasRef = useRef(null);
            const chartRef = useRef(null);

            useEffect(() => {
                if (!canvasRef.current || data.length === 0) return;

                const ctx = canvasRef.current.getContext('2d');

                // æ—¢å­˜ã®ãƒãƒ£ãƒ¼ãƒˆã‚’ç ´æ£„
                if (chartRef.current) {
                    chartRef.current.destroy();
                }

                // ãƒ‡ãƒ¼ã‚¿ã‚’æº–å‚™
                const labels = data.map(d => {
                    const date = new Date(d.datetime);
                    return date.toLocaleString('ja-JP', { 
                        month: 'numeric', 
                        day: 'numeric', 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    });
                });
                const tideValues = data.map(d => d.tide);

                // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆï¼ˆãƒ¡ã‚¤ãƒ³ãƒ‡ãƒ¼ã‚¿ç”¨ï¼‰
                const gradient = ctx.createLinearGradient(0, 0, 0, 400);
                gradient.addColorStop(0, 'rgba(59, 130, 246, 0.5)');
                gradient.addColorStop(1, 'rgba(59, 130, 246, 0.1)');

                // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆï¼ˆæ¯”è¼ƒãƒ‡ãƒ¼ã‚¿ç”¨ï¼‰
                const comparisonGradient = ctx.createLinearGradient(0, 0, 0, 400);
                comparisonGradient.addColorStop(0, 'rgba(251, 191, 36, 0.3)');
                comparisonGradient.addColorStop(1, 'rgba(251, 191, 36, 0.05)');

                // ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã®æº–å‚™
                const datasets = [{
                    label: title === 'å®Ÿæ¸¬å€¤' ? 'å®Ÿæ¸¬æ½®ä½ (cm)' : 'äºˆæ¸¬æ½®ä½ (cm)',
                    data: tideValues,
                    borderColor: data[0]?.type === 'observed' ? 'rgb(16, 185, 129)' : 'rgb(59, 130, 246)',
                    backgroundColor: data[0]?.type === 'observed' ? 'rgba(16, 185, 129, 0.3)' : gradient,
                    borderWidth: 2,
                    fill: true,
                    tension: 0.4,
                    pointRadius: 0,
                    pointHoverRadius: 5
                }];

                // æ¯”è¼ƒãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯è¿½åŠ 
                if (comparisonData && comparisonData.length > 0) {
                    const comparisonValues = comparisonData.map(d => d.tide);
                    datasets.push({
                        label: 'äºˆæ¸¬æ½®ä½ (cm)',
                        data: comparisonValues,
                        borderColor: 'rgb(251, 191, 36)',
                        backgroundColor: comparisonGradient,
                        borderWidth: 2,
                        borderDash: [5, 5],
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0,
                        pointHoverRadius: 5
                    });
                }

                // annotationãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’ç™»éŒ²
                if (!Chart.registry.plugins.get('annotation')) {
                    Chart.register(window['chartjs-plugin-annotation'].default);
                }

                // ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š
                const annotations = {
                    threshold: {
                        type: 'line',
                        yMin: threshold,
                        yMax: threshold,
                        borderColor: 'rgb(239, 68, 68)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        label: {
                            content: `é–¾å€¤ ${threshold}cm`,
                            display: true,
                            position: 'end'
                        }
                    }
                };

                // ç¾åœ¨æ™‚åˆ»ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’è¿½åŠ 
                if (showCurrentTime) {
                    const now = new Date();
                    const nowStr = now.toLocaleString('ja-JP', { 
                        month: 'numeric', 
                        day: 'numeric', 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    });
                    const currentIndex = labels.findIndex(label => {
                        const labelDate = new Date(data[labels.indexOf(label)]?.datetime);
                        return Math.abs(labelDate - now) < 5 * 60 * 1000; // 5åˆ†ä»¥å†…
                    });

                    if (currentIndex !== -1) {
                        annotations.currentTime = {
                            type: 'point',
                            xValue: currentIndex,
                            yValue: tideValues[currentIndex],
                            backgroundColor: 'rgb(239, 68, 68)',
                            borderColor: 'white',
                            borderWidth: 2,
                            radius: 8,
                            label: {
                                content: 'ç¾åœ¨',
                                display: true,
                                position: 'top'
                            }
                        };
                    }
                }

                // ãƒãƒ£ãƒ¼ãƒˆä½œæˆ
                chartRef.current = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return context.dataset.label + ': ' + context.parsed.y + ' cm';
                                    }
                                }
                            },
                            annotation: {
                                annotations: annotations
                            }
                        },
                        scales: {
                            x: {
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45,
                                    autoSkip: true,
                                    maxTicksLimit: 20
                                }
                            },
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'æ½®ä½ (cm)'
                                }
                            }
                        }
                    }
                });

                return () => {
                    if (chartRef.current) {
                        chartRef.current.destroy();
                    }
                };
            }, [data, threshold, comparisonData, showCurrentTime]);

            return (
                <div style={{ position: 'relative', height: '100%', width: '100%' }}>
                    <canvas ref={canvasRef}></canvas>
                </div>
            );
        };

        const TidalFlatSystem = () => {
            const [threshold, setThreshold] = useState(120);
            const [minTime, setMinTime] = useState(6);
            const [maxTime, setMaxTime] = useState(18);
            const [showSettings, setShowSettings] = useState(false);
            const [activeTab, setActiveTab] = useState('prediction'); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’7æ—¥é–“äºˆæ¸¬ã«
            
            const [observedData, setObservedData] = useState([]);
            const [predictionData, setPredictionData] = useState([]);
            const [lastUpdate, setLastUpdate] = useState({
                observed: null,
                prediction: null
            });
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);

            useEffect(() => {
                const loadData = async () => {
                    try {
                        setError(null);
                        
                        const obsResponse = await fetch('./data/observed/latest.json');
                        if (obsResponse.ok) {
                            const obsData = await obsResponse.json();
                            setObservedData(obsData);
                            setLastUpdate(prev => ({ ...prev, observed: new Date() }));
                        }
                        
                        const predResponse = await fetch('./data/prediction/latest.json');
                        if (predResponse.ok) {
                            const predData = await predResponse.json();
                            setPredictionData(predData);
                            setLastUpdate(prev => ({ ...prev, prediction: new Date() }));
                        }
                        
                        setLoading(false);
                    } catch (err) {
                        console.error('ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', err);
                        setError('ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚GitHub Actionsã§ãƒ‡ãƒ¼ã‚¿å–å¾—ä¸­ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚');
                        setLoading(false);
                    }
                };
                
                loadData();
                const interval = setInterval(loadData, 5 * 60 * 1000);
                return () => clearInterval(interval);
            }, []);

            const calculateTidalFlatPeriods = (data) => {
                const periods = [];
                let currentPeriod = null;

                data.forEach((point) => {
                    const pointDate = new Date(point.datetime);
                    const hour = pointDate.getHours();
                    const isDaytime = hour >= minTime && hour < maxTime;
                    
                    if (point.tide <= threshold) {
                        if (!currentPeriod) {
                            currentPeriod = {
                                start: point.datetime,
                                minTide: point.tide,
                                daytimeHours: 0,
                                hasDaytime: false,
                                points: [point]
                            };
                        } else {
                            currentPeriod.points.push(point);
                            if (point.tide < currentPeriod.minTide) {
                                currentPeriod.minTide = point.tide;
                            }
                        }
                        if (isDaytime) {
                            currentPeriod.daytimeHours += (data[0].type === 'observed' ? 5/60 : 1);
                            currentPeriod.hasDaytime = true;
                        }
                    } else {
                        if (currentPeriod && currentPeriod.points.length > 0) {
                            const startDate = new Date(currentPeriod.start);
                            const endDate = new Date(currentPeriod.points[currentPeriod.points.length - 1].datetime);
                            currentPeriod.end = currentPeriod.points[currentPeriod.points.length - 1].datetime;
                            currentPeriod.duration = (endDate - startDate) / (1000 * 60 * 60);
                            periods.push(currentPeriod);
                            currentPeriod = null;
                        }
                    }
                });

                if (currentPeriod && currentPeriod.points.length > 0) {
                    const startDate = new Date(currentPeriod.start);
                    const endDate = new Date(currentPeriod.points[currentPeriod.points.length - 1].datetime);
                    currentPeriod.end = currentPeriod.points[currentPeriod.points.length - 1].datetime;
                    currentPeriod.duration = (endDate - startDate) / (1000 * 60 * 60);
                    periods.push(currentPeriod);
                }

                return periods;
            };

            // ä»Šæ—¥ã®äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ã¨å®Ÿæ¸¬ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆæ¯”è¼ƒç”¨ï¼‰
            const getTodayComparisonData = () => {
                const today = new Date();
                const todayStr = today.toISOString().split('T')[0];
                
                // ä»Šæ—¥ã®äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ï¼ˆ0æ™‚ã€œ23æ™‚ï¼‰
                const todayPrediction = predictionData.filter(d => {
                    return d.datetime.startsWith(todayStr);
                });
                
                // ä»Šæ—¥ã®å®Ÿæ¸¬ãƒ‡ãƒ¼ã‚¿
                const todayObserved = observedData.filter(d => {
                    return d.datetime.startsWith(todayStr);
                });
                
                return { todayPrediction, todayObserved };
            };

            const { todayPrediction, todayObserved } = getTodayComparisonData();

            const tidalFlatPeriods = useMemo(() => {
                const data = activeTab === 'observed' ? observedData : predictionData;
                return calculateTidalFlatPeriods(data);
            }, [observedData, predictionData, threshold, minTime, maxTime, activeTab]);

            const stats = useMemo(() => {
                const daytimePeriods = tidalFlatPeriods.filter(p => p.hasDaytime);
                const totalDaytimeHours = daytimePeriods.reduce((sum, p) => sum + p.daytimeHours, 0);
                
                return {
                    totalPeriods: tidalFlatPeriods.length,
                    daytimePeriods: daytimePeriods.length,
                    totalDaytimeHours: totalDaytimeHours,
                    bestPeriod: tidalFlatPeriods.reduce((best, p) => 
                        !best || p.minTide < best.minTide ? p : best, null)
                };
            }, [tidalFlatPeriods]);

            const formatTime = (datetime) => {
                const date = new Date(datetime);
                return `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
            };

            const formatDate = (datetime) => {
                const date = new Date(datetime);
                return `${date.getMonth() + 1}/${date.getDate()}`;
            };

            const formatDuration = (hours) => {
                const h = Math.floor(hours);
                const m = Math.round((hours - h) * 60);
                if (h === 0) return `${m}åˆ†`;
                if (m === 0) return `${h}æ™‚é–“`;
                return `${h}æ™‚é–“${m}åˆ†`;
            };

            const formatUpdateTime = (date) => {
                if (!date) return '---';
                const now = new Date();
                const diff = Math.floor((now - date) / 60000);
                if (diff < 1) return 'ãŸã£ãŸä»Š';
                if (diff < 60) return `${diff}åˆ†å‰`;
                const hours = Math.floor(diff / 60);
                if (hours < 24) return `${hours}æ™‚é–“å‰`;
                return date.toLocaleString('ja-JP');
            };

            const groupPeriodsByDate = () => {
                const grouped = {};
                tidalFlatPeriods.forEach(period => {
                    const date = formatDate(period.start);
                    if (!grouped[date]) grouped[date] = [];
                    grouped[date].push(period);
                });
                return grouped;
            };

            if (loading) {
                return (
                    <div className="container">
                        <div className="card loading">
                            <div style={{fontSize: '3rem'}}>ğŸ”„</div>
                            <p>ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ä¸­...</p>
                        </div>
                    </div>
                );
            }

            if (error) {
                return (
                    <div className="container">
                        <div className="card">
                            <div className="error">
                                <strong>âŒ ã‚¨ãƒ©ãƒ¼</strong>
                                <p>{error}</p>
                                <p style={{marginTop: '1rem', fontSize: '0.875rem'}}>
                                    GitHub Actionsã‚¿ãƒ–ã§ã€ŒUpdate Observed Tide Dataã€ã¨ã€ŒUpdate Tide Prediction Dataã€ã‚’æ‰‹å‹•å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚
                                </p>
                            </div>
                        </div>
                    </div>
                );
            }

            const periodsByDate = groupPeriodsByDate();

            return (
                <div className="container">
                    <div className="card">
                        <h1 className="header">
                            <span style={{fontSize: '2.5rem'}}>ğŸ–ï¸</span>
                            ç´å±‹æ¸¯ å¹²æ½Ÿå‡ºç¾äºˆæ¸¬ã‚·ã‚¹ãƒ†ãƒ 
                        </h1>
                        <p className="subtitle">æµ·ä¸Šä¿å®‰åºãƒ‡ãƒ¼ã‚¿è‡ªå‹•å–å¾—ãƒ»ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°å¯¾å¿œ</p>
                        
                        <div className="update-info">
                            <div className="update-item">
                                <span>ğŸ•</span>
                                <span>å®Ÿæ¸¬ãƒ‡ãƒ¼ã‚¿æ›´æ–°: <strong style={{color: '#2563eb'}}>{formatUpdateTime(lastUpdate.observed)}</strong></span>
                            </div>
                            <div className="update-item">
                                <span>ğŸ“ˆ</span>
                                <span>äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿æ›´æ–°: <strong style={{color: '#059669'}}>{formatUpdateTime(lastUpdate.prediction)}</strong></span>
                            </div>
                        </div>
                    </div>

                    <div className="card">
                        <div className="tabs">
                            <button 
                                className={`tab ${activeTab === 'prediction' ? 'active' : 'inactive'}`}
                                onClick={() => setActiveTab('prediction')}
                            >
                                ğŸ“Š 7æ—¥é–“äºˆæ¸¬
                            </button>
                            <button 
                                className={`tab ${activeTab === 'observed' ? 'active' : 'inactive'}`}
                                onClick={() => setActiveTab('observed')}
                            >
                                ğŸ“ˆ å®Ÿæ¸¬å€¤ï¼ˆ24æ™‚é–“ï¼‰
                            </button>
                            <button 
                                className={`tab ${activeTab === 'comparison' ? 'active' : 'inactive'}`}
                                onClick={() => setActiveTab('comparison')}
                            >
                                ğŸ”„ äºˆæ¸¬vså®Ÿæ¸¬
                            </button>
                        </div>
                    </div>

                    <div className="card">
                        <h2 style={{fontSize: '1.125rem', fontWeight: 'bold', marginBottom: '1rem'}}>
                            {activeTab === 'prediction' && 'ğŸ“Š 7æ—¥é–“æ½®ä½äºˆæ¸¬'}
                            {activeTab === 'observed' && 'ğŸ“ˆ å®Ÿæ¸¬æ½®ä½ï¼ˆ24æ™‚é–“ï¼‰'}
                            {activeTab === 'comparison' && 'ğŸ”„ ä»Šæ—¥ã®äºˆæ¸¬ vs å®Ÿæ¸¬'}
                        </h2>
                        <div className={`chart-wrapper ${activeTab === 'observed' || activeTab === 'comparison' ? 'no-scroll' : ''}`}>
                            <div className={`chart-container ${activeTab === 'observed' || activeTab === 'comparison' ? 'full-width' : ''}`}>
                                {activeTab === 'comparison' ? (
                                    <TideChart 
                                        data={todayObserved.length > 0 ? todayObserved : todayPrediction}
                                        comparisonData={todayObserved.length > 0 ? todayPrediction : null}
                                        threshold={threshold}
                                        title="æ¯”è¼ƒ"
                                        showCurrentTime={true}
                                    />
                                ) : activeTab === 'observed' ? (
                                    <TideChart 
                                        data={observedData.slice(-288)}
                                        threshold={threshold}
                                        title="å®Ÿæ¸¬å€¤"
                                        showCurrentTime={false}
                                    />
                                ) : (
                                    <TideChart 
                                        data={predictionData}
                                        threshold={threshold}
                                        title="äºˆæ¸¬å€¤"
                                        showCurrentTime={true}
                                    />
                                )}
                            </div>
                        </div>
                        {activeTab === 'prediction' && (
                            <div className="scroll-hint">â† ã‚¹ãƒ¯ã‚¤ãƒ—ã—ã¦å…¨ä½“ã‚’è¡¨ç¤º â†’</div>
                        )}
                    </div>

                    <div className="stats-grid">
                        <div className="stat-card">
                            <div className="stat-label">å¹²æ½Ÿå‡ºç¾å›æ•°</div>
                            <div className="stat-value" style={{color: '#2563eb'}}>{stats.totalPeriods}å›</div>
                        </div>
                        <div className="stat-card">
                            <div className="stat-label">æ˜¼é–“ä½œæ¥­å¯èƒ½</div>
                            <div className="stat-value" style={{color: '#059669'}}>{stats.daytimePeriods}å›</div>
                        </div>
                        <div className="stat-card">
                            <div className="stat-label">æ˜¼é–“ä½œæ¥­æ™‚é–“</div>
                            <div className="stat-value" style={{color: '#ea580c'}}>{formatDuration(stats.totalDaytimeHours)}</div>
                        </div>
                        <div className="stat-card">
                            <div className="stat-label">æœ€ä½æ½®ä½</div>
                            <div className="stat-value" style={{color: '#9333ea'}}>
                                {stats.bestPeriod ? `${stats.bestPeriod.minTide}cm` : '-'}
                            </div>
                        </div>
                    </div>

                    <div className="card">
                        <button 
                            onClick={() => setShowSettings(!showSettings)}
                            style={{background: 'none', border: 'none', cursor: 'pointer', fontSize: '1.125rem', fontWeight: 'bold', marginBottom: '1rem'}}
                        >
                            âš™ï¸ è¡¨ç¤ºè¨­å®š {showSettings ? 'â–¼' : 'â–¶'}
                        </button>
                        
                        {showSettings && (
                            <div className="settings-panel">
                                <div className="setting-item">
                                    <label>å¹²æ½Ÿåˆ¤å®šé–¾å€¤: {threshold}cm</label>
                                    <input
                                        type="range"
                                        min="50"
                                        max="150"
                                        value={threshold}
                                        onChange={(e) => setThreshold(parseInt(e.target.value))}
                                    />
                                </div>
                                <div className="setting-item">
                                    <label>ä½œæ¥­é–‹å§‹æ™‚åˆ»: {minTime}:00</label>
                                    <input
                                        type="range"
                                        min="0"
                                        max="23"
                                        value={minTime}
                                        onChange={(e) => setMinTime(parseInt(e.target.value))}
                                    />
                                </div>
                                <div className="setting-item">
                                    <label>ä½œæ¥­çµ‚äº†æ™‚åˆ»: {maxTime}:00</label>
                                    <input
                                        type="range"
                                        min="1"
                                        max="24"
                                        value={maxTime}
                                        onChange={(e) => setMaxTime(parseInt(e.target.value))}
                                    />
                                </div>
                            </div>
                        )}
                    </div>

                    <div className="card">
                        <h2 style={{fontSize: '1.25rem', fontWeight: 'bold', marginBottom: '1rem'}}>
                            ğŸ“… å¹²æ½Ÿå‡ºç¾ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
                        </h2>
                        
                        {Object.entries(periodsByDate).slice(0, 14).map(([date, periods]) => (
                            <div key={date} style={{marginBottom: '1.5rem'}}>
                                <h3 style={{fontSize: '1.125rem', fontWeight: 'bold', marginBottom: '0.75rem'}}>
                                    {date}
                                </h3>
                                
                                {periods.map((period, idx) => (
                                    <div 
                                        key={idx}
                                        className={`period-card ${period.hasDaytime ? 'daytime' : 'nighttime'}`}
                                    >
                                        <div className="period-header">
                                            <div>
                                                <div className="period-time">
                                                    {period.hasDaytime ? 'â˜€ï¸' : 'ğŸŒ™'} {formatTime(period.start)} ã€œ {formatTime(period.end)}
                                                    <span style={{marginLeft: '0.5rem', fontSize: '0.875rem', color: '#6b7280'}}>
                                                        ({formatDuration(period.duration)})
                                                    </span>
                                                </div>
                                                <div style={{fontSize: '0.875rem', marginTop: '0.5rem'}}>
                                                    <span style={{color: '#6b7280'}}>æœ€ä½æ½®ä½:</span>
                                                    <strong style={{marginLeft: '0.5rem', color: '#2563eb'}}>{period.minTide}cm</strong>
                                                    {period.hasDaytime && (
                                                        <>
                                                            <span style={{marginLeft: '1rem', color: '#6b7280'}}>æ˜¼é–“ä½œæ¥­:</span>
                                                            <strong style={{marginLeft: '0.5rem', color: '#ea580c'}}>
                                                                {formatDuration(period.daytimeHours)}
                                                            </strong>
                                                        </>
                                                    )}
                                                </div>
                                            </div>
                                            <div>
                                                {period.minTide < 50 && (
                                                    <span className="badge badge-green">åºƒç¯„å›²</span>
                                                )}
                                                {period.minTide >= 50 && period.minTide < 90 && (
                                                    <span className="badge badge-blue">ä¸­ç¨‹åº¦</span>
                                                )}
                                                {period.minTide >= 90 && (
                                                    <span className="badge badge-gray">éƒ¨åˆ†çš„</span>
                                                )}
                                            </div>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        ))}
                    </div>

                    <div className="info-box">
                        <strong>â„¹ï¸ è‡ªå‹•æ›´æ–°ã‚·ã‚¹ãƒ†ãƒ </strong>
                        <ul>
                            <li>å®Ÿæ¸¬ãƒ‡ãƒ¼ã‚¿: 30åˆ†ã”ã¨ã«æµ·ä¸Šä¿å®‰åºã‹ã‚‰è‡ªå‹•å–å¾—</li>
                            <li>äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿: æ¯æ—¥0æ™‚ã«7æ—¥åˆ†ã®äºˆæ¸¬ã‚’æ›´æ–°</li>
                            <li>ãƒ‡ãƒ¼ã‚¿ä¿å­˜: JSONå½¢å¼ã§GitHubã«è‡ªå‹•ã‚³ãƒŸãƒƒãƒˆ</li>
                            <li>ãƒ‡ãƒ¼ã‚¿ä»¶æ•°: å®Ÿæ¸¬ {observedData.length}ä»¶ã€äºˆæ¸¬ {predictionData.length}ä»¶</li>
                        </ul>
                    </div>
                </div>
            );
        };
        
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<TidalFlatSystem />);
    </script>
</body>
</html>

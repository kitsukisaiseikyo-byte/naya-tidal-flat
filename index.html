<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç´å±‹æ¸¯ å¹²æ½Ÿå‡ºç¾äºˆæ¸¬ã‚·ã‚¹ãƒ†ãƒ </title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/recharts@2.10.3/dist/Recharts.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useMemo } = React;
        const { AreaChart, Area, LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, ReferenceLine } = Recharts;
        
        // Lucide icons
        const Calendar = () => <span>ğŸ“…</span>;
        const Sun = () => <span>â˜€ï¸</span>;
        const Moon = () => <span>ğŸŒ™</span>;
        const Info = () => <span>â„¹ï¸</span>;
        const Settings = () => <span>âš™ï¸</span>;
        const RefreshCw = () => <span>ğŸ”„</span>;
        const Clock = () => <span>ğŸ•</span>;
        const TrendingUp = () => <span>ğŸ“ˆ</span>;

        const TidalFlatSystem = () => {
            const [threshold, setThreshold] = useState(120);
            const [minTime, setMinTime] = useState(6);
            const [maxTime, setMaxTime] = useState(18);
            const [showSettings, setShowSettings] = useState(false);
            const [chartDays, setChartDays] = useState(7);
            const [activeTab, setActiveTab] = useState('prediction');
            
            const [observedData, setObservedData] = useState([]);
            const [predictionData, setPredictionData] = useState([]);
            const [lastUpdate, setLastUpdate] = useState({
                observed: null,
                prediction: null
            });
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);

            useEffect(() => {
                const loadData = async () => {
                    try {
                        setError(null);
                        
                        // å®Ÿæ¸¬ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
                        const obsResponse = await fetch('./data/observed/latest.json');
                        if (obsResponse.ok) {
                            const obsData = await obsResponse.json();
                            setObservedData(obsData);
                            setLastUpdate(prev => ({ ...prev, observed: new Date() }));
                        }
                        
                        // äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
                        const predResponse = await fetch('./data/prediction/latest.json');
                        if (predResponse.ok) {
                            const predData = await predResponse.json();
                            setPredictionData(predData);
                            setLastUpdate(prev => ({ ...prev, prediction: new Date() }));
                        }
                        
                        setLoading(false);
                    } catch (err) {
                        console.error('ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', err);
                        setError('ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + err.message);
                        setLoading(false);
                    }
                };
                
                loadData();
                
                // 5åˆ†ã”ã¨ã«å†èª­ã¿è¾¼ã¿
                const interval = setInterval(loadData, 5 * 60 * 1000);
                return () => clearInterval(interval);
            }, []);

            const calculateTidalFlatPeriods = (data) => {
                const periods = [];
                let currentPeriod = null;

                data.forEach((point) => {
                    const pointDate = new Date(point.datetime);
                    const hour = pointDate.getHours();
                    const isDaytime = hour >= minTime && hour < maxTime;
                    
                    if (point.tide <= threshold) {
                        if (!currentPeriod) {
                            currentPeriod = {
                                start: point.datetime,
                                minTide: point.tide,
                                minTideTime: point.datetime,
                                daytimeHours: 0,
                                hasDaytime: false,
                                points: [point]
                            };
                        } else {
                            currentPeriod.points.push(point);
                            if (point.tide < currentPeriod.minTide) {
                                currentPeriod.minTide = point.tide;
                                currentPeriod.minTideTime = point.datetime;
                            }
                        }
                        if (isDaytime) {
                            currentPeriod.daytimeHours += (data[0].type === 'observed' ? 5/60 : 1);
                            currentPeriod.hasDaytime = true;
                        }
                    } else {
                        if (currentPeriod && currentPeriod.points.length > 0) {
                            const startDate = new Date(currentPeriod.start);
                            const endDate = new Date(currentPeriod.points[currentPeriod.points.length - 1].datetime);
                            currentPeriod.end = currentPeriod.points[currentPeriod.points.length - 1].datetime;
                            currentPeriod.duration = (endDate - startDate) / (1000 * 60 * 60);
                            
                            periods.push(currentPeriod);
                            currentPeriod = null;
                        }
                    }
                });

                if (currentPeriod && currentPeriod.points.length > 0) {
                    const startDate = new Date(currentPeriod.start);
                    const endDate = new Date(currentPeriod.points[currentPeriod.points.length - 1].datetime);
                    currentPeriod.end = currentPeriod.points[currentPeriod.points.length - 1].datetime;
                    currentPeriod.duration = (endDate - startDate) / (1000 * 60 * 60);
                    periods.push(currentPeriod);
                }

                return periods;
            };

            const tidalFlatPeriods = useMemo(() => {
                const data = activeTab === 'observed' ? observedData : predictionData;
                return calculateTidalFlatPeriods(data);
            }, [observedData, predictionData, threshold, minTime, maxTime, activeTab]);

            const stats = useMemo(() => {
                const daytimePeriods = tidalFlatPeriods.filter(p => p.hasDaytime);
                const totalDaytimeHours = daytimePeriods.reduce((sum, p) => sum + p.daytimeHours, 0);
                
                return {
                    totalPeriods: tidalFlatPeriods.length,
                    daytimePeriods: daytimePeriods.length,
                    totalDaytimeHours: totalDaytimeHours,
                    bestPeriod: tidalFlatPeriods.reduce((best, p) => 
                        !best || p.minTide < best.minTide ? p : best, null)
                };
            }, [tidalFlatPeriods]);

            const formatTime = (datetime) => {
                const date = new Date(datetime);
                return `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
            };

            const formatDuration = (hours) => {
                const h = Math.floor(hours);
                const m = Math.round((hours - h) * 60);
                if (h === 0) return `${m}åˆ†`;
                if (m === 0) return `${h}æ™‚é–“`;
                return `${h}æ™‚é–“${m}åˆ†`;
            };

            const formatUpdateTime = (date) => {
                if (!date) return '---';
                const now = new Date();
                const diff = Math.floor((now - date) / 60000);
                if (diff < 1) return 'ãŸã£ãŸä»Š';
                if (diff < 60) return `${diff}åˆ†å‰`;
                const hours = Math.floor(diff / 60);
                if (hours < 24) return `${hours}æ™‚é–“å‰`;
                return date.toLocaleString('ja-JP');
            };

            if (loading) {
                return (
                    <div className="w-full min-h-screen bg-gradient-to-br from-blue-50 to-cyan-50 flex items-center justify-center">
                        <div className="text-center">
                            <RefreshCw />
                            <p className="text-gray-600 mt-4">ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ä¸­...</p>
                        </div>
                    </div>
                );
            }

            if (error) {
                return (
                    <div className="w-full min-h-screen bg-gradient-to-br from-blue-50 to-cyan-50 flex items-center justify-center">
                        <div className="text-center bg-white p-8 rounded-lg shadow-lg max-w-md">
                            <p className="text-red-600 font-semibold mb-4">âŒ ã‚¨ãƒ©ãƒ¼</p>
                            <p className="text-gray-600">{error}</p>
                            <p className="text-sm text-gray-500 mt-4">
                                ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ãŒç”Ÿæˆã•ã‚Œã‚‹ã¾ã§ãŠå¾…ã¡ãã ã•ã„ã€‚<br/>
                                GitHub Actionsã§ãƒ‡ãƒ¼ã‚¿å–å¾—ä¸­ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
                            </p>
                        </div>
                    </div>
                );
            }

            const chartData = activeTab === 'observed' 
                ? observedData.slice(-288)
                : predictionData.slice(0, chartDays * 24);

            return (
                <div className="w-full min-h-screen bg-gradient-to-br from-blue-50 to-cyan-50 p-4 md:p-6">
                    <div className="max-w-7xl mx-auto space-y-6">
                        <div className="bg-white rounded-lg shadow-lg p-6">
                            <h1 className="text-2xl md:text-3xl font-bold text-gray-800 mb-2 flex items-center gap-3">
                                <span className="text-4xl">ğŸ–ï¸</span>
                                ç´å±‹æ¸¯ å¹²æ½Ÿå‡ºç¾äºˆæ¸¬ã‚·ã‚¹ãƒ†ãƒ 
                            </h1>
                            <p className="text-gray-600 text-sm md:text-base mb-4">
                                æµ·ä¸Šä¿å®‰åºãƒ‡ãƒ¼ã‚¿è‡ªå‹•å–å¾—ãƒ»ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°å¯¾å¿œ
                            </p>
                            
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-3 text-sm">
                                <div className="flex items-center gap-2 text-gray-600">
                                    <Clock />
                                    <span>å®Ÿæ¸¬ãƒ‡ãƒ¼ã‚¿æ›´æ–°:</span>
                                    <span className="font-semibold text-blue-600">
                                        {formatUpdateTime(lastUpdate.observed)}
                                    </span>
                                </div>
                                <div className="flex items-center gap-2 text-gray-600">
                                    <TrendingUp />
                                    <span>äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿æ›´æ–°:</span>
                                    <span className="font-semibold text-green-600">
                                        {formatUpdateTime(lastUpdate.prediction)}
                                    </span>
                                </div>
                            </div>
                        </div>

                        <div className="bg-white rounded-lg shadow-lg p-4">
                            <div className="flex gap-2 flex-wrap">
                                <button
                                    onClick={() => setActiveTab('prediction')}
                                    className={`px-4 py-2 rounded-lg font-medium transition-colors ${
                                        activeTab === 'prediction'
                                            ? 'bg-blue-600 text-white'
                                            : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                    }`}
                                >
                                    ğŸ“Š 7æ—¥é–“äºˆæ¸¬
                                </button>
                                <button
                                    onClick={() => setActiveTab('observed')}
                                    className={`px-4 py-2 rounded-lg font-medium transition-colors ${
                                        activeTab === 'observed'
                                            ? 'bg-green-600 text-white'
                                            : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                    }`}
                                >
                                    ğŸ“ˆ å®Ÿæ¸¬å€¤ï¼ˆ24æ™‚é–“ï¼‰
                                </button>
                            </div>
                        </div>

                        <div className="grid grid-cols-2 md:grid-cols-4 gap-3 md:gap-4">
                            <div className="bg-white rounded-lg shadow p-4">
                                <div className="text-xs md:text-sm text-gray-600 mb-1">å¹²æ½Ÿå‡ºç¾å›æ•°</div>
                                <div className="text-xl md:text-2xl font-bold text-blue-600">{stats.totalPeriods}å›</div>
                            </div>
                            <div className="bg-white rounded-lg shadow p-4">
                                <div className="text-xs md:text-sm text-gray-600 mb-1">æ˜¼é–“ä½œæ¥­å¯èƒ½</div>
                                <div className="text-xl md:text-2xl font-bold text-green-600">{stats.daytimePeriods}å›</div>
                            </div>
                            <div className="bg-white rounded-lg shadow p-4">
                                <div className="text-xs md:text-sm text-gray-600 mb-1">æ˜¼é–“ä½œæ¥­æ™‚é–“</div>
                                <div className="text-xl md:text-2xl font-bold text-orange-600">
                                    {formatDuration(stats.totalDaytimeHours)}
                                </div>
                            </div>
                            <div className="bg-white rounded-lg shadow p-4">
                                <div className="text-xs md:text-sm text-gray-600 mb-1">æœ€ä½æ½®ä½</div>
                                <div className="text-xl md:text-2xl font-bold text-purple-600">
                                    {stats.bestPeriod ? `${stats.bestPeriod.minTide}cm` : '-'}
                                </div>
                            </div>
                        </div>

                        <div className="bg-white rounded-lg shadow-lg p-6">
                            <h2 className="text-lg md:text-xl font-bold text-gray-800 mb-4">
                                {activeTab === 'prediction' ? '7æ—¥é–“æ½®ä½äºˆæ¸¬' : 'å®Ÿæ¸¬æ½®ä½ï¼ˆç›´è¿‘24æ™‚é–“ï¼‰'}
                            </h2>
                            
                            {chartData.length > 0 ? (
                                <ResponsiveContainer width="100%" height={400}>
                                    <AreaChart data={chartData}>
                                        <CartesianGrid strokeDasharray="3 3" />
                                        <XAxis 
                                            dataKey="datetime"
                                            tickFormatter={(value) => {
                                                const date = new Date(value);
                                                const hour = date.getHours();
                                                if (activeTab === 'observed') {
                                                    return hour % 3 === 0 ? `${hour}:00` : '';
                                                }
                                                return hour === 0 ? `${date.getMonth()+1}/${date.getDate()}` : hour % 6 === 0 ? `${hour}:00` : '';
                                            }}
                                        />
                                        <YAxis label={{ value: 'æ½®ä½ (cm)', angle: -90, position: 'insideLeft' }} />
                                        <Tooltip 
                                            labelFormatter={(value) => new Date(value).toLocaleString('ja-JP')}
                                            formatter={(value) => [value + 'cm', 'æ½®ä½']}
                                        />
                                        <ReferenceLine y={threshold} stroke="#ef4444" strokeDasharray="3 3" label="é–¾å€¤" />
                                        <Area 
                                            type="monotone" 
                                            dataKey="tide" 
                                            stroke={activeTab === 'observed' ? '#10b981' : '#3b82f6'}
                                            fill={activeTab === 'observed' ? '#86efac' : '#93c5fd'}
                                            fillOpacity={0.6}
                                        />
                                    </AreaChart>
                                </ResponsiveContainer>
                            ) : (
                                <p className="text-center text-gray-500 py-8">ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“</p>
                            )}
                        </div>

                        <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
                            <div className="flex items-start gap-3">
                                <Info />
                                <div className="text-sm text-gray-700">
                                    <p className="font-semibold mb-2">ğŸ¤– è‡ªå‹•æ›´æ–°ã‚·ã‚¹ãƒ†ãƒ </p>
                                    <ul className="space-y-1 list-disc list-inside">
                                        <li>å®Ÿæ¸¬ãƒ‡ãƒ¼ã‚¿: 30åˆ†ã”ã¨ã«æµ·ä¸Šä¿å®‰åºã‹ã‚‰è‡ªå‹•å–å¾—</li>
                                        <li>äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿: æ¯æ—¥0æ™‚ã«7æ—¥åˆ†ã®äºˆæ¸¬ã‚’æ›´æ–°</li>
                                        <li>ãƒ‡ãƒ¼ã‚¿ä¿å­˜: JSONå½¢å¼ã§GitHubã«è‡ªå‹•ã‚³ãƒŸãƒƒãƒˆ</li>
                                        <li>ãƒ‡ãƒ¼ã‚¿ä»¶æ•°: å®Ÿæ¸¬ {observedData.length}ä»¶ã€äºˆæ¸¬ {predictionData.length}ä»¶</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };
        
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<TidalFlatSystem />);
    </script>
</body>
</html>
